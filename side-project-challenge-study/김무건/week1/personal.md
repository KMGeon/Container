# MySQL 에서 최적화를 위한 설정들은 무엇일지 특히, 인덱스 에서 자료구조 관점에서 장단점 조사

1. 버퍼 풀 크기 설정 : innodb_buffer_pool_size
버퍼 풀 크기는 MySQL이 데이터를 메모리에 캐싱하는 크기입니다. 
이 값을 적절히 설정하면 디스크 I/O를 줄이고 쿼리 성능을 향상시킬 수 있습니다. 

버퍼 풀은 DBMS가 할당한 메모리 공간에서 구성되며, 읽어온 데이터는 버퍼 풀에 저장됩니다. 이후, 같은 데이터가 다시 필요한 경우에는 디스크에서 읽어오지 않고 버퍼 풀에서 빠르게 데이터를 읽어와서 처리합니다.

- 예를 들어 SELECT 쿼리를 실행을 하게 되면
   1. 쿼리 입력 값에 대한 해시 값을 생성
   2. 키에 해시 값 / 값에 쿼리의 결과 값을 저장하게 된다.
   3. 캐시에서 결과 값을 찾을 수 없으면 디스크에서 데이터를 읽어온다.


2. 쿼리 캐시 크기 설정 : query_cache_size
쿼리 캐시 크기는 쿼리 결과를 캐싱하는 크기입니다. 
쿼리 결과를 캐싱하면 동일한 쿼리를 실행할 때 빠르게 결과를 반환할 수 있으므로 쿼리 성능이 향상됩니다. 
하지만 쿼리 캐시 크기를 너무 크게 설정하면 메모리 부족으로 인한 성능 저하가 발생할 수 있으므로 적절한 값을 설정해야 합니다.

3. 로그 레벨 설정 : log_error_verbosity
로그 레벨을 높여서 디버깅을 할 때 유용합니다. 로그 레벨을 높이면 MySQL에서 발생하는 오류 및 경고 메시지를 더 자세하게 확인할 수 있습니다.

4. 인덱스 설정 : index_merge
인덱스 설정은 데이터베이스에서 데이터를 빠르게 검색하는 데 매우 중요합니다. 
MySQL에서는 인덱스를 이용해 데이터를 검색하는데, 여러 개의 인덱스를 사용할 때 index_merge 옵션을 활성화하면 더욱 빠르게 데이터를 검색할 수 있습니다.

- index_merge 옵션??
여러 개의 인덱스를 조합해 데이터를 검색하는 옵션이다.

```sql
SELECT * FROM table_name
WHERE column1 = 'value1'
AND column2 = 'value2'
```
위에 쿼리를 살펴보면 만약에 각각의 조건에 인덱스 1,2가 존재한다면 index_merge 옵션을 사용하여
각각의 조건에 해당하는 레코드를 검색하는 것보다 빠르게 데이터를 검색할 수 있다.

5. 쓰기 작업의 지연 설정 : innodb_flush_log_at_trx_commit
   1. 트랜잭션 커밋 시 디스크에 저장 x , 버퍼 풀에 데이터 유지 -> 가장 빠르지만 시스템이 꺼지면 버퍼 풀이 날라가서 위험
   2. 커밋 시마다 디스크에 데이터 저장 : 데이터 일관성이 좋다. 하지만 성능이 떨어진다.
   3. 커밋 시 디스크에 데이터 기록 x , 버퍼 풀에 데이터를 유지하지만 1초마다 디스크에 기록 : 일관성 , 성능을 다 고려

- 기본적으로 2 방식을 사용한다. 0,2를 설정하여 성능을 높일 수 있다.

# 자료구조 관점에서 알아보자
1. MySQL은 기본적으로 B-Tree를 사용한다. 이 구조는 이진트리와 비슷하지만 다르다.
여기서 B는 바이너리가 아닌 Balance를 의미 
![image](https://user-images.githubusercontent.com/103854287/224346966-56f83908-2a6c-4f8e-858b-cc3d07791c85.png)
![image](https://user-images.githubusercontent.com/103854287/224347012-9204d57e-0699-4cd3-abc5-83453274c628.png)
![image](https://user-images.githubusercontent.com/103854287/224347038-400917cf-db3f-4572-bbaf-3a35c4f4f441.png)

- B-Tree란
바이너리 서치 트리에서 발전되어 모든 리프노드들이 같은 레벨을 가질 수 있도록 자동으로 균형을 맞추는 트리
이진트리와 다르게 하나의 노드에 많은 트리를 가지고 있다.

여기서 탐색의 과정을 살펴보면
1. 루트 노드에서 시작으로 하양식으로 key 검색을 수행 한다.
   - 만약에 k와 같은 키를 찾으면 탐색 종료
   - 검색하는 값들과 key들의 대소관계를 비교하며 어떠한 key 사이에 k가 존재한다면 자식 노드로 진행

2. 해당 과정은 리프 노드에 도달할 때까지 반복
3. 만약에 리프 노드에 k가 없으면 검색 실패

### 분할과 병합
- 분할은 리프 노드에 삽입을 하였을 때 새로운 키 값이 해당 리프 노드에 이미 존재하면 삽입 연산이 실패한다.
- 이때 b-tree는 리프 노드를 분할하여 새로운 키 값을 저장할 공간을 확보
- 노드가 움직이는 것이 아니라 새로운 리프 노드를 생성

- 병합은 삭제 연산을 할 때 키 값이 저장된 노드가 리프 노드인 경우 해당 노드를 삭제하고
- 리프 노드의 수를 줄인다. 이 때 인접한 노드를 합쳐서 하나의 노드로 만든다.
![image](https://user-images.githubusercontent.com/103854287/224347070-dcd2fa1e-8121-41dc-8d04-622d66da9a3c.png)
